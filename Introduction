If you want to know more about my first C++ application which is a prototype operator that fuse words, you can read Feudal_VS_Imperials in FacebookTrash repository.

If you really don't know from where to start, I will give you a clue from scratch.

If you think about the way you have to destroy the trash in your everyday life to reduce the risk of an epidemic disaster, you should know some chemistry secret code to get to know how

to free the volume from those compound things that nobody wants anymore.

Howewer yet, if you think about fusing words as a feudal member, you will have 3 different ways to deal with the imperial word generator overproducing wastes you may not know how

to get rid of.

So, the purpose of the game is to gain the widest possible range over the imperial word generator.

Over the process, you will regenerate an almost lost feudal sunk power, but still powerful enough to change your fate.

Dropping something away means not using that word anymore for what's going to follow.

The name pattern you use may follow some maths transforms you should consider to face some computing issues as well.

Once it done, what could possibly done by example would be to fuse fuel and metal, which result with the prototype operator would be fusmetl, or as reversed, would be ltemsuf.

The word simply give a clue about a subitem.

There is no subitem in the current prototype operator !

All words can be fused equally with common lower case or common uppercase.

Howewer, the imperial process may indicate that from a given dictionary, a subitem structure can be implemented so the words cannot all be fused indifferently because of the imperials

aspect that fuse word operator may have by default.

If you want to correct that, you should think about a method subitem that will implement a hierarchy between words, which constraints may describe an object which definition would be

a feudal group of words defining a class of fusion. let's interpret the fusion result differently : the inverse result was ltemsuf.
With uppercase, you can get an Ljaw5ng, as a non-reverse short gnaj, which may be the half part of the winning condition of your game concept.

If such feudal group can be built, you get half part of the winning condition for the game concept.

What is the missing part ?

The missing part is the game difficulty based upon the word length and the amount of words to deal with.

For a certain amount of words with a certain length, if the feudal group is being built, you win the game.

But if a word exceed a certain length, or if the amount is being too high, you loose the game because your feudal group would be useless in such conditions...

I think I am done with the game concept.

I hope that will help you in your project.

Please comment and give advice, because I am not that experimented in code.*

<br>Note:</br> the code that has been publish publically may not be a problem. The problem will come out for those who don't take into account the different feudal classes that may

play a great role for that fuse words prototype operators, because I am a great fan of war strategy games.

Then, if you want to enrole new troops or if you want to destroy a powerful army, the fuse words operator may be required but the way you may acquire it as a functional

game mecanic system may not give the same result.

Here is why I introduce the game concept on this way, because my prototype operator does really depends on what the user knows, about how he is thinking the problem.

The program cannot morph the letters, but I won't develop a letter morpher for some security reasons.

The most important is that what is not taken into account in the current war strategy games is that your real power strength may become your real weakness if you end up into

a feudal disposal, because you may wipe out your ally instead of the enemy.

Howewer yet, turning it into a game code, if two developers get such disposals and are great coders but don't know each other, they may self destroy each other and let their seat

to a less skillful coder.

The skills are not so important because what is requested here is to follow a path that will secure your application development by setting up a winning and a loose condition 

about the result of the application itself.
